"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const asyncModules_1 = require("../base/asyncModules");
/**
 * Controllers for working with blocks
 */
class BlocksApi extends asyncModules_1.default {
    constructor(state) {
        super(state);
        this._url = state.url + '/api/content/blocks';
    }
    /**
     * Get blocks by parameters.
     *
     * @param {BlockType} type - Available values : forCatalogProducts, forBasketPage, forErrorPage, forCatalogPages, forProductPreview, forProductPage, forSimilarProductBlock, forStatisticProductBlock, forProductBlock, forForm, forFormField, forNewsPage, forNewsBlock, forNewsPreview, forOneNewsPage, forUsualPage, forTextBlock, forSlider, forOrder, service
     * @param {string} [langCode] - Language code. Default "en_US"
     * @param {number} [offset] - Parameter for pagination. Default 0
     * @param {number} [limit] - Parameter for pagination. Default 30
     *
     * @returns Return array of BlocksEntity object.
     */
    async getBlocks(type, langCode = this.state.lang, offset = 0, limit = 30) {
        const response = await this._fetchGet(`?langCode=${langCode}&type=${type}&offset=${offset}&limit=${limit}`);
        if (this.state.multipleResponse) {
            const normalizeResponse = this._normalizeData(response.items);
            await Promise.all(normalizeResponse.map(async (block) => {
                const customSettings = block.customSettings;
                if (customSettings && customSettings.hasOwnProperty('productConfig')) {
                    block.countElementsPerRow = customSettings.productConfig.countElementsPerRow ? (+customSettings.productConfig.countElementsPerRow) : 0;
                }
                else {
                    block.countElementsPerRow = 0;
                }
                delete block.customSettings;
                delete block.attributesSetIdentifier;
                delete block.productPageUrls;
                if (block.type === 'forSimilarProductBlock') {
                    try {
                        await this.getSimilarProducts(block.identifier, langCode, offset, limit).then((result) => {
                            block.similarProducts = result;
                        });
                    }
                    catch {
                        block.similarProducts = [];
                    }
                }
                else if (block.type === 'forProductBlock') {
                    try {
                        await this.getProductsByBlockMarker(block.identifier, langCode, offset, limit).then((result) => {
                            block.products = result;
                        });
                    }
                    catch {
                        block.products = [];
                    }
                }
            }));
            return this._normalizeData(normalizeResponse);
        }
        return this._normalizeData(response.items);
    }
    /**
     * Get block by marker.
     *
     * @param {string} marker - Marker of Block.
     * @param {string} [langCode] - Language code. Default "en_US"
     *
     * @returns Return BlocksEntity object.
     */
    async getBlockByMarker(marker, langCode = this.state.lang) {
        const response = await this._fetchGet(`/marker/${marker}?langCode=${langCode}`);
        const normalizeResponse = this._normalizeData(response);
        const customSettings = normalizeResponse.customSettings;
        if (customSettings && customSettings.hasOwnProperty('productConfig')) {
            normalizeResponse.countElementsPerRow = customSettings.productConfig.countElementsPerRow ? (+customSettings.productConfig.countElementsPerRow) : 0;
        }
        else {
            normalizeResponse.countElementsPerRow = 0;
        }
        delete normalizeResponse.customSettings;
        delete normalizeResponse.attributesSetIdentifier;
        delete normalizeResponse.productPageUrls;
        if (this.state.multipleResponse) {
            if (normalizeResponse.type === 'forSimilarProductBlock') {
                try {
                    await this.getSimilarProducts(normalizeResponse.identifier, langCode).then((result) => {
                        normalizeResponse.similarProducts = result;
                    });
                }
                catch {
                    normalizeResponse.similarProducts = [];
                }
            }
            else if (normalizeResponse.type === 'forProductBlock') {
                try {
                    await this.getProductsByBlockMarker(normalizeResponse.identifier, langCode).then((result) => {
                        normalizeResponse.products = result;
                    });
                }
                catch {
                    normalizeResponse.products = [];
                }
            }
        }
        return this._normalizeData(normalizeResponse);
    }
    /**
     * Get similar products by block marker.
     *
     * @param {string} marker - Block identifier
     * @param {string} [langCode] - Language code. Default "en_US"
     * @param {number} [offset] - Parameter for pagination. Default 0
     * @param {number} [limit] - Parameter for pagination. Default 30
     *
     * @returns Return array of BlocksEntity object.
     */
    async getSimilarProducts(marker, langCode = this.state.lang, offset = 0, limit = 30) {
        const result = await this._fetchGet(`/${marker}/similar-products?langCode=${langCode}&offset=${offset}&limit=${limit}`);
        return this._normalizeData(result.items);
    }
    /**
     * Get products by block marker.
     *
     * @param {string} marker - Block identifier
     * @param {string} [langCode] - Language code. Default "en_US"
     * @param {number} [offset] - Parameter for pagination. Default 0
     * @param {number} [limit] - Parameter for pagination. Default 30
     *
     * @returns Return array of BlocksEntity object.
     */
    async getProductsByBlockMarker(marker, langCode = this.state.lang, offset = 0, limit = 30) {
        const result = await this._fetchGet(`/${marker}/products?langCode=${langCode}&offset=${offset}&limit=${limit}`);
        return this._normalizeData(result.items);
    }
    /**
     * Quick search for block objects with limited output
     * @param name - Search string
     * @param [langCode] - Language code. Default "en_US"
     */
    async searchBlock(name, langCode = this.state.lang) {
        const result = await this._fetchGet(`/quick/search?langCode=${langCode}&name=${name}`);
        return result;
    }
}
exports.default = BlocksApi;
