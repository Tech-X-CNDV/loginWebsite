type Types = 'forCatalogProducts' | 'forBasketPage' | 'forErrorPage' | 'forCatalogPages' | 'forProductPreview' | 'forProductPage' | 'forSimilarProductBlock' | 'forStatisticProductBlock' | 'forProductBlock' | 'forForm' | 'forFormField' | 'forNewsPage' | 'forNewsBlock' | 'forNewsPreview' | 'forOneNewsPage' | 'forUsualPage' | 'forTextBlock' | 'forSlider' | 'forOrder' | 'service' | 'none';
/**
 * @param {string} [token] - If your project is protected by a token, specify this token in this parameter.
 * @param {string} [langCode] - specify the default language to avoid specifying it in every request.
 * @param {boolean} [traficLimit] - Some methods use multiple queries to make it easier to work with the API. Set this parameter to "false" to save traffic and decide for yourself what data you need.
 * @param {boolean} [auth] - An object with authorization settings
 * @param {boolean} [auth.customAuth] - Set this flag to true if you want to configure the authorization process yourself. Set the flag to false, or do not pass it at all to have automatic authorization and token renewal
 * @param {boolean} [auth.refreshToken] - Transfer the refresh token here, for example from the local storage, to resume the user's session. Otherwise, the user will need to log in every time a new session is created
 * @param {boolean} [auth.saveFunction] - If you want to store the token between sessions, for example in local storage, create a custom function that takes refreshToken as a parameter and executes the necessary instructions. This function will be called every time the tokens are updated
 *
 * @example
 * const saveToken = (token) => {
 *     localStorage.setItem('refresh', token)
 * }
 *
 * const config = {
 *     token: 'project.token.here',
 *     langCode: 'en_US',
 *     multipleRequests: true,
 *     auth: {
 *         customAuth: false,
 *         refreshToken: 'user.refresh.token',
 *         saveFunction: saveToken
 *     }
 * }
 *
 */
interface IConfig {
    token?: string;
    langCode?: string;
    traficLimit?: boolean;
    auth?: {
        customAuth?: boolean;
        refreshToken?: string;
        saveFunction?: (refreshToken: string) => void;
    };
}
interface IAttributes {
    listTitles: Array<{
        title: string;
        value: number | string | null;
        position: number;
        extended: {
            value: string | number | null;
            type: string | number | null;
        };
    }>;
    localizeInfos: ILocalizeInfo;
    marker: string;
    position: number;
    isVisible: boolean;
    type: string;
    validators: Record<string, any>;
}
interface ILocalizeInfos {
    [key: string]: ILocalizeInfo;
}
interface ILocalizeInfo {
    [key: string]: any;
}
interface IAttributeValues {
    [key: string]: IAttributeValue;
}
interface IAttributeValue {
    [key: string]: any;
}
type AttributeType = IAttributeValues | IAttributeValue;
interface IAttributeSetEntity {
    id: number;
    updatedDate: string;
    version: number;
    identifier: string;
    typeId: number;
    localizeInfos: LocalizeType;
    schema: Record<string, any>;
    position: {
        id: number;
        objectId: number;
        objectType: string;
        position: number | string;
    };
    positionId: number | string;
    isVisible: boolean;
}
type LangType = string | Array<string>;
type LocalizeType = ILocalizeInfos | ILocalizeInfo;
interface IError {
    message: string;
    pageData: any;
    statusCode: number;
    timestamp: string;
    [key: string]: any;
}
export { LocalizeType, ILocalizeInfos, ILocalizeInfo, Types, IAttributeSetEntity, LangType, AttributeType, IAttributeValues, IAttributes, IConfig, IError };
