"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const syncModules_1 = require("./syncModules");
class AsyncModules extends syncModules_1.default {
    constructor(state) {
        var _a;
        super(state);
        this._url = this.state.url;
        this.state = state;
        this._NO_FETCH = state._NO_FETCH;
        this._https = (_a = state._https) !== null && _a !== void 0 ? _a : null;
    }
    async _fetchGet(path) {
        const options = this.makeOptions('GET');
        if (!this._NO_FETCH) {
            return await this.browserResponse(path, options);
        }
        else {
            return new Promise((resolve, reject) => {
                const req = this._https.get(this._getFullPath(path), options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => {
                        data += chunk;
                    });
                    res.on('end', () => {
                        resolve(JSON.parse(data));
                    });
                });
                req.on('error', (error) => {
                    reject(error);
                });
            });
        }
    }
    async _fetchPost(path, data) {
        const options = this.makeOptions('POST', data);
        if (!this._NO_FETCH) {
            return await this.browserResponse(path, options);
        }
        else {
            return new Promise((resolve, reject) => {
                const req = this._https.request(this._getFullPath(path), options, (res) => {
                    let responseData = '';
                    res.on('data', (chunk) => {
                        responseData += chunk;
                    });
                    res.on('end', () => {
                        try {
                            resolve(JSON.parse(responseData));
                        }
                        catch (error) {
                            resolve(responseData);
                        }
                    });
                });
                req.on('error', (error) => {
                    reject(error);
                });
                req.write(JSON.stringify(data));
                req.end();
            });
        }
    }
    async _fetchPut(path, data) {
        const options = this.makeOptions('PUT', data);
        if (!this._NO_FETCH) {
            return await this.browserResponse(path, options);
        }
        else {
            return new Promise((resolve, reject) => {
                const req = this._https.request(this._getFullPath(path), options, (res) => {
                    let responseData = '';
                    res.on('data', (chunk) => {
                        responseData += chunk;
                    });
                    res.on('end', () => {
                        resolve(JSON.parse(responseData));
                    });
                });
                req.on('error', (error) => {
                    reject(error);
                });
                req.write(JSON.stringify(data));
                req.end();
            });
        }
    }
    async _fetchDelete(path, data) {
        const options = this.makeOptions('DELETE');
        if (!this._NO_FETCH) {
            return await this.browserResponse(path, options);
        }
        else {
            return new Promise((resolve, reject) => {
                const req = this._https.delete(this._getFullPath(path), options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => {
                        data += chunk;
                    });
                    res.on('end', () => {
                        resolve(JSON.parse(data));
                    });
                });
                req.on('error', (error) => {
                    reject(error);
                });
            });
        }
    }
    async refreshToken() {
        const response = await fetch(this.state.url + `/api/content/users-auth-providers/marker/email/users/refresh`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-app-token': this.state.token
            },
            body: JSON.stringify({ refreshToken: this.state.refreshToken })
        });
        if (response.ok) {
            const result = await response.json();
            this.state.refreshToken = result.refreshToken;
            this.state.accessToken = result.accessToken;
            if (this.state.saveFunction) {
                this.state.saveFunction(result.refreshToken);
            }
            return true;
        }
        else {
            return false;
        }
    }
    makeOptions(method, data) {
        const options = {
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'x-app-token': this.state.token,
            }
        };
        if (data instanceof FormData || data instanceof Blob) {
            delete options.headers['Content-Type'];
        }
        if (data) {
            options['body'] = JSON.stringify(data);
        }
        if (this.state.accessToken) {
            options.headers['Authorization'] = 'Bearer ' + this.state.accessToken;
        }
        return options;
    }
    async browserResponse(path, options) {
        const response = await fetch(this._getFullPath(path), options);
        if (response.status == 401 && !this.state.customAuth) {
            const refresh = await this.refreshToken();
            if (refresh) {
                options.headers['Authorization'] = 'Bearer ' + this.state.accessToken;
                const secondResponse = await fetch(this._getFullPath(path), options);
                return await secondResponse.json();
            }
        }
        if (!response.ok) {
            const error = await response.json();
            throw error;
        }
        try {
            return await response.json();
        }
        catch (e) {
            return response;
        }
    }
}
exports.default = AsyncModules;
